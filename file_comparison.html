<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Guidance Code Evolution</title>
    
    <!-- Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link href="https://fonts.googleapis.com/css?family=Google+Sans|Noto+Sans|Castoro" rel="stylesheet">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Noto Sans', sans-serif;
            background: #fafafa;
            color: #363636;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 24px;
            font-weight: 600;
            color: #363636;
            font-family: 'Google Sans', sans-serif;
        }

        .carousel-container {
            position: relative;
            overflow: hidden;
        }

        .carousel-wrapper {
            display: flex;
            transition: transform 0.5s ease-in-out;
        }

        .carousel-item {
            min-width: 100%;
            padding: 0 10px;
        }

        .code-card {
            background: #ffffff;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            border: 1px solid #dbdbdb;
        }

        .code-header {
            background: #f5f5f5;
            padding: 15px 20px;
            border-bottom: 1px solid #dbdbdb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .code-title {
            font-size: 16px;
            font-weight: 600;
            color: #363636;
            font-family: 'Google Sans', sans-serif;
        }

        .iteration-badge {
            background: #3273dc;
            color: #fff;
            padding: 5px 14px;
            border-radius: 4px;
            font-size: 13px;
            font-weight: 600;
        }

        .code-content {
            max-height: 500px;
            overflow-y: auto;
            padding: 0;
        }

        .code-content::-webkit-scrollbar {
            width: 8px;
        }

        .code-content::-webkit-scrollbar-track {
            background: #f5f5f5;
        }

        .code-content::-webkit-scrollbar-thumb {
            background: #b5b5b5;
            border-radius: 4px;
        }

        .code-content::-webkit-scrollbar-thumb:hover {
            background: #999;
        }

        pre {
            margin: 0 !important;
            padding: 20px !important;
            background: #2b2b2b !important;
        }

        pre code {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.6;
        }

        .carousel-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin-top: 25px;
        }

        .carousel-button {
            background: #3273dc;
            border: none;
            color: #fff;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .carousel-button:hover:not(:disabled) {
            background: #275aa8;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .carousel-button:disabled {
            background: #dbdbdb;
            color: #7a7a7a;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .carousel-indicators {
            display: flex;
            gap: 10px;
        }

        .indicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #dbdbdb;
            cursor: pointer;
            transition: all 0.2s;
        }

        .indicator:hover {
            background: #b5b5b5;
        }

        .indicator.active {
            background: #3273dc;
            transform: scale(1.2);
        }

        .slide-info {
            color: #7a7a7a;
            font-size: 14px;
            font-weight: 500;
        }

        @media (max-width: 768px) {
            body {
                padding: 10px;
            }

            h1 {
                font-size: 20px;
                margin-bottom: 20px;
            }

            .code-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .carousel-controls {
                flex-direction: column;
                gap: 15px;
            }

            pre code {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Guidance Code Evolution</h1>
        
        <div class="carousel-container">
            <div class="carousel-wrapper" id="carouselWrapper">
                <!-- Slide 1: guidance_code_0.py -->
                <div class="carousel-item">
                    <div class="code-card">
                        <div class="code-header">
                            <span class="code-title">guidance_code_0.py</span>
                            <span class="iteration-badge">Iteration 0</span>
                        </div>
                        <div class="code-content">
                            <pre><code class="language-python">from motor_cortex.common.perception_functions import get_position, get_size, get_orientation
import numpy as np

# Helper function to calculate distance
def calculate_distance(pos1, pos2):
    return np.linalg.norm(np.array(pos1) - np.array(pos2))

def guidance(state, previous_vars_dict={'pressed_maroon': False, 'pressed_green': False}):
    score = 0.0
    vars_dict = previous_vars_dict.copy()
    
    # Get positions of the buttons
    maroon_button_pos = get_position('maroon_button')
    green_button_pos = get_position('green_button')
    
    # Robot's current position
    robot_pos = state[:3]  # x, y, z
    
    if not vars_dict['pressed_maroon']:
        # Calculate distance to maroon button
        distance_to_maroon = calculate_distance(robot_pos, maroon_button_pos)
        score = max(0, 1 - distance_to_maroon)  # Score increases as robot gets closer
        
        # Check if the robot is close enough to press the maroon button
        if distance_to_maroon < 0.1:  # Assuming 0.1m is the pressing distance
            vars_dict['pressed_maroon'] = True
            score += 1.0  # Bonus for pressing the button
    elif not vars_dict['pressed_green']:
        # Calculate distance to green button
        distance_to_green = calculate_distance(robot_pos, green_button_pos)
        score = max(0, 1 - distance_to_green)  # Score increases as robot gets closer
        
        # Check if the robot is close enough to press the green button
        if distance_to_green < 0.1:  # Assuming 0.1m is the pressing distance
            vars_dict['pressed_green'] = True
            score += 1.0  # Bonus for pressing the button

    return score, vars_dict
</code></pre>
                        </div>
                    </div>
                </div>

                <!-- Slide 2: guidance_code_5.py -->
                <div class="carousel-item">
                    <div class="code-card">
                        <div class="code-header">
                            <span class="code-title">guidance_code_5.py</span>
                            <span class="iteration-badge">Iteration 5</span>
                        </div>
                        <div class="code-content">
                            <pre><code class="language-python">from motor_cortex.common.perception_functions import get_position, get_size, get_orientation
import numpy as np

# Helper function to calculate distance
def calculate_distance(pos1, pos2):
    return np.linalg.norm(np.array(pos1) - np.array(pos2))

def guidance(state, previous_vars_dict={'pressed_maroon': False, 'pressed_green': False}):
    score = 0.0
    vars_dict = previous_vars_dict.copy()
    
    # Get positions and sizes of the buttons
    maroon_button_pos = get_position('maroon_button')
    green_button_pos = get_position('green_button')
    maroon_button_size = get_size('maroon_button')
    green_button_size = get_size('green_button')
    
    # Robot's current position and orientation
    robot_pos = state[:3]  # x, y, z
    robot_orientation = state[3:6]  # rotation_x, rotation_y, rotation_z
    
    if not vars_dict['pressed_maroon']:
        # Calculate distance to maroon button
        distance_to_maroon = calculate_distance(robot_pos, maroon_button_pos)
        score = max(0, 1 - distance_to_maroon)  # Score increases as robot gets closer
        
        # Check if the robot is close enough to press the maroon button
        if distance_to_maroon < maroon_button_size[0] / 2:  # Dynamic pressing distance
            # Confirm pressing action (placeholder for actual sensor check)
            if confirm_button_press('maroon_button'):
                vars_dict['pressed_maroon'] = True
                score += 1.0  # Bonus for pressing the button
    elif not vars_dict['pressed_green']:
        # Calculate distance to green button
        distance_to_green = calculate_distance(robot_pos, green_button_pos)
        score = max(0, 1 - distance_to_green)  # Score increases as robot gets closer
        
        # Check if the robot is close enough to press the green button
        if distance_to_green < green_button_size[0] / 2:  # Dynamic pressing distance
            # Confirm pressing action (placeholder for actual sensor check)
            if confirm_button_press('green_button'):
                vars_dict['pressed_green'] = True
                score += 1.0  # Bonus for pressing the button

    # Penalty for moving away from the buttons after pressing
    if vars_dict['pressed_maroon'] and not vars_dict['pressed_green']:
        distance_to_green_after_press = calculate_distance(robot_pos, green_button_pos)
        score -= max(0, distance_to_green_after_press - 0.2)  # Penalty for moving away

    return score, vars_dict

def confirm_button_press(button_name):
    # Placeholder function for actual button press confirmation logic
    return True  # Assume the button press is successful for now
</code></pre>
                        </div>
                    </div>
                </div>

                <!-- Slide 3: guidance_code_10.py -->
                <div class="carousel-item">
                    <div class="code-card">
                        <div class="code-header">
                            <span class="code-title">guidance_code_10.py</span>
                            <span class="iteration-badge">Iteration 10</span>
                        </div>
                        <div class="code-content">
                            <pre><code class="language-python">from motor_cortex.common.perception_functions import get_position, get_size, get_orientation
import numpy as np

# Helper function to calculate distance
def calculate_distance(pos1, pos2):
    return np.linalg.norm(np.array(pos1) - np.array(pos2))

# Improved path planning function (to be implemented)
def plan_path(start_pos, target_pos):
    # Implement a path planning algorithm (e.g., A* or Dijkstra's) here
    # For now, return a direct line to the target position
    return target_pos

def guidance(state, previous_vars_dict={'pressed_maroon': False, 'pressed_green': False}):
    score = 0.0
    vars_dict = previous_vars_dict.copy()
    
    # Get positions and sizes of the buttons
    maroon_button_pos = get_position('maroon_button')
    green_button_pos = get_position('green_button')
    maroon_button_size = get_size('maroon_button')
    green_button_size = get_size('green_button')
    
    # Robot's current position and orientation
    robot_pos = state[:3]  # x, y, z
    robot_orientation = state[3:6]  # rotation_x, rotation_y, rotation_z
    
    if not vars_dict['pressed_maroon']:
        # Calculate distance to maroon button
        distance_to_maroon = calculate_distance(robot_pos, maroon_button_pos)
        score += max(0, 1 - distance_to_maroon)  # Score increases as robot gets closer
        
        # Check if the robot is close enough to press the maroon button
        if distance_to_maroon < maroon_button_size[0] / 2:  # Dynamic pressing distance
            # Confirm pressing action with actual sensor feedback
            if confirm_button_press('maroon_button', robot_pos):
                vars_dict['pressed_maroon'] = True
                score += 1.0  # Bonus for pressing the button
    elif not vars_dict['pressed_green']:
        # Calculate distance to green button
        distance_to_green = calculate_distance(robot_pos, green_button_pos)
        score += max(0, 1 - distance_to_green)  # Score increases as robot gets closer
        
        # Check if the robot is close enough to press the green button
        if distance_to_green < green_button_size[0] / 2:  # Dynamic pressing distance
            # Confirm pressing action with actual sensor feedback
            if confirm_button_press('green_button', robot_pos):
                vars_dict['pressed_green'] = True
                score += 1.0  # Bonus for pressing the button

    # Direct movement towards the green button after pressing the maroon button
    if vars_dict['pressed_maroon'] and not vars_dict['pressed_green']:
        # Plan a path to the green button
        target_position = plan_path(robot_pos, green_button_pos)
        # Update robot's position towards the target position
        robot_pos = target_position  # Simulate movement towards the target
        distance_to_green_after_press = calculate_distance(robot_pos, green_button_pos)
        score -= max(0, distance_to_green_after_press - 0.2)  # Penalty for moving away

    return score, vars_dict

def confirm_button_press(button_name, robot_pos):
    # Implement actual sensor feedback to confirm button press
    button_pos = get_position(button_name)
    distance_to_button = calculate_distance(robot_pos, button_pos)
    return distance_to_button < 0.05  # Assume success if within 5 cm
</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="carousel-controls">
            <button class="carousel-button" id="prevBtn" onclick="changeSlide(-1)">
                <span>←</span>
                <span>Previous</span>
            </button>
            
            <div class="carousel-indicators" id="indicators">
                <div class="indicator active" onclick="goToSlide(0)"></div>
                <div class="indicator" onclick="goToSlide(1)"></div>
                <div class="indicator" onclick="goToSlide(2)"></div>
            </div>
            
            <span class="slide-info" id="slideInfo">1 / 3</span>
            
            <button class="carousel-button" id="nextBtn" onclick="changeSlide(1)">
                <span>Next</span>
                <span>→</span>
            </button>
        </div>
    </div>

    <!-- Prism.js for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

    <script>
        let currentSlide = 0;
        const totalSlides = 3;

        function updateCarousel() {
            const wrapper = document.getElementById('carouselWrapper');
            const indicators = document.querySelectorAll('.indicator');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');
            const slideInfo = document.getElementById('slideInfo');

            // Update slide position
            wrapper.style.transform = `translateX(-${currentSlide * 100}%)`;

            // Update indicators
            indicators.forEach((indicator, index) => {
                indicator.classList.toggle('active', index === currentSlide);
            });

            // Update button states
            prevBtn.disabled = currentSlide === 0;
            nextBtn.disabled = currentSlide === totalSlides - 1;

            // Update slide info
            slideInfo.textContent = `${currentSlide + 1} / ${totalSlides}`;
        }

        function changeSlide(direction) {
            currentSlide += direction;
            if (currentSlide < 0) currentSlide = 0;
            if (currentSlide >= totalSlides) currentSlide = totalSlides - 1;
            updateCarousel();
        }

        function goToSlide(index) {
            currentSlide = index;
            updateCarousel();
        }

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') changeSlide(-1);
            if (e.key === 'ArrowRight') changeSlide(1);
        });

        // Initialize
        updateCarousel();

        // Re-highlight code after page load
        document.addEventListener('DOMContentLoaded', () => {
            Prism.highlightAll();
        });
    </script>
</body>
</html>
